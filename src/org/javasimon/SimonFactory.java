package org.javasimon;

import java.util.*;
import java.util.logging.Logger;
import java.util.logging.Level;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.io.*;

/**
 * SimonFactory.
 *
 * @author <a href="mailto:virgo47@gmail.com">Richard "Virgo" Richter</a>
 * @created Aug 4, 2008
 */
public final class SimonFactory {
	public static final String PROPERTY_CONFIG_FILE_NAME = "javasimon.config.file";

	public static final String PROPERTY_CONFIG_RESOURCE_NAME = "javasimon.config.resource";

	public static final String HIERARCHY_DELIMITER = ".";

	public static final String ROOT_SIMON_NAME = "";

	private static final Map<String, AbstractSimon> allSimons = new HashMap<String, AbstractSimon>();

	private static UnknownSimon rootSimon;

	private static Factory factory = EnabledFactory.INSTANCE;

	static {
		reset();
		try {
			initFromConfig();
		} catch (IOException e) {
			Logger.getLogger(SimonFactory.class.getName()).log(Level.SEVERE, "Simon config couldn't be processed correctly", e);
		}
	}

	private static void initFromConfig() throws IOException {
		String fileName = System.getProperty(PROPERTY_CONFIG_FILE_NAME);
		if (fileName != null) {
			FileReader reader = new FileReader(fileName);
			try {
				initFromReader(reader);
			} finally {
				reader.close();
			}
		}
		String resourceName = System.getProperty(PROPERTY_CONFIG_RESOURCE_NAME);
		if (resourceName != null) {
			InputStreamReader reader = new InputStreamReader(SimonFactory.class.getClassLoader().getResourceAsStream(resourceName));
			try {
				initFromReader(reader);
			} finally {
				reader.close();
			}
		}
	}

	private static void initFromReader(Reader reader) throws IOException {
		Properties properties = new Properties();
		properties.load(reader);
		for (String name : properties.stringPropertyNames()) {
			String simonType = null;
			StatProcessorType statProcessorType = StatProcessorType.NULL;
			String value = properties.getProperty(name);
			for (String keyword : value.split(" +")) {
				if (keyword.equals("stopwatch")) {
					simonType = keyword;
				} else if (keyword.equals("counter")) {
					simonType = keyword;
				} else if (keyword.equals("basic")) {
					statProcessorType = StatProcessorType.BASIC;
				}
			}
			if (simonType != null) {
				Simon simon = null;
				if (simonType.equals("stopwatch")) {
					simon = getStopwatch(name);
				} else if (simonType.equals("counter")) {
					simon = getCounter(name);
				}
				if (simon != null) {
					simon.setStatProcessor(statProcessorType.create());
				}
			}
		}
	}

	private SimonFactory() {
		throw new UnsupportedOperationException();
	}

	/**
	 * Returns Simon by its name if it exists.
	 *
	 * @param name name of the Simon
	 * @return simon object
	 */
	public static Simon getSimon(String name) {
		return factory.getSimon(name);
	}

	/**
	 * Returns existing SimonCounter or creates new if necessary.
	 *
	 * @param name name of the counter
	 * @return counter object
	 */
	public static Counter getCounter(String name) {
		return factory.getCounter(name);
	}

	/**
	 * Returns existing stopwatch or creates new if necessary.
	 *
	 * @param name name of the Stopwatch
	 * @return stopwatch object
	 */
	public static Stopwatch getStopwatch(String name) {
		return factory.getStopwatch(name);
	}

	/**
	 * Returns existing simple stopwatch or creates new if necessary. Simple stopwatch is not threadsafe.
	 *
	 * @param name name of the Stopwatch
	 * @return stopwatch object
	 */
	public static Stopwatch getSimpleStopwatch(String name) {
		return factory.getStopwatch(name);
	}

	/**
	 * Autogenerates name for the Simon.
	 *
	 * @param suffix name suffix for eventual Simon discrimination
	 * @param includeMethodName if true, method name will be included in the name thus effectively adding another level
	 * of hierarchy
	 * @return autogenerated name for Simon
	 */
	public static String generateName(String suffix, boolean includeMethodName) {
		return factory.generateName(suffix, includeMethodName);
	}

	private static Simon getOrCreateSimon(String name, Class<? extends AbstractSimon> simonClass) {
		Simon simon = allSimons.get(name);
		if (simon == null) {
			simon = newSimon(name, simonClass);
		} else if (simon instanceof UnknownSimon) {
			simon = replaceSimon(simon, simonClass);
		} else {
			if (!(simonClass.isInstance(simon))) {
				throw new SimonException("Simon named '" + name + "' already exists and its type is '" + simon.getClass().getName() + "' while requested type is '" + simonClass.getName() + "'.");
			}
		}
		return simon;
	}

	private static Simon replaceSimon(Simon simon, Class<? extends AbstractSimon> simonClass) {
		AbstractSimon newSimon = instantiateSimon(simon.getName(), simonClass);
		// fixes parent link and parent's children list
		((AbstractSimon) simon.getParent()).replace(simon, newSimon);

		// fixes children list and all children's parent link
		for (Simon child : simon.getChildren()) {
			newSimon.addChild((AbstractSimon) child);
			((AbstractSimon) child).setParent(newSimon);
		}

		allSimons.put(simon.getName(), newSimon);
		return newSimon;
	}

	private static Simon newSimon(String name, Class<? extends AbstractSimon> simonClass) {
		AbstractSimon simon = instantiateSimon(name, simonClass);
		if (name != null) {
			addToHierarchy(simon, name);
		}
		return simon;
	}

	private static AbstractSimon instantiateSimon(String name, Class<? extends AbstractSimon> simonClass) {
		AbstractSimon simon;
		try {
			Constructor<? extends AbstractSimon> constructor = simonClass.getConstructor(String.class);
			simon = constructor.newInstance(name);
		} catch (NoSuchMethodException e) {
			throw new SimonException(e);
		} catch (InvocationTargetException e) {
			throw new SimonException(e);
		} catch (IllegalAccessException e) {
			throw new SimonException(e);
		} catch (InstantiationException e) {
			throw new SimonException(e);
		}
		return simon;
	}

	private static void addToHierarchy(AbstractSimon simon, String name) {
		allSimons.put(name, simon);
		int ix = name.lastIndexOf(HIERARCHY_DELIMITER);
		AbstractSimon parent = rootSimon;
		if (ix != -1) {
			String parentName = name.substring(0, ix);
			parent = allSimons.get(parentName);
			if (parent == null) {
				parent = new UnknownSimon(parentName);
				addToHierarchy(parent, parentName);
			}
		}
		parent.addChild(simon);
	}

	public static void enable() {
		factory = EnabledFactory.INSTANCE;
	}

	public static void disable() {
		factory = DisabledFactory.INSTANCE;
	}

	public static boolean isEnabled() {
		return factory instanceof EnabledFactory;
	}

	public static Simon getRootSimon() {
		return factory.getRootSimon();
	}

	public static Collection<String> simonNames() {
		return factory.simonNames();
	}

	public static void reset() {
		allSimons.clear();
		rootSimon = new UnknownSimon(ROOT_SIMON_NAME);
		allSimons.put(ROOT_SIMON_NAME, rootSimon);
	}

	private static class EnabledFactory implements Factory {
		public static final Factory INSTANCE = new EnabledFactory();

		public Simon getSimon(String name) {
			return allSimons.get(name);
		}

		public synchronized Counter getCounter(String name) {
			return (Counter) getOrCreateSimon(name, CounterImpl.class);
		}

		public synchronized Stopwatch getStopwatch(String name) {
			return (Stopwatch) getOrCreateSimon(name, StopwatchImpl.class);
		}

		public Stopwatch getSimpleStopwatch(String name) {
			return (Stopwatch) getOrCreateSimon(name, SimpleStopwatch.class);
		}

		public String generateName(String suffix, boolean includeMethodName) {
			StackTraceElement stackElement = Thread.currentThread().getStackTrace()[3];
			StringBuilder nameBuilder = new StringBuilder(stackElement.getClassName());
			if (includeMethodName) {
				nameBuilder.append('.').append(stackElement.getMethodName());
			}
			if (suffix != null) {
				nameBuilder.append(suffix);
			}
			return nameBuilder.toString();
		}

		public Simon getRootSimon() {
			return rootSimon;
		}

		public Collection<String> simonNames() {
			return allSimons.keySet();
		}
	}

	private static class DisabledFactory implements Factory {
		public static final Factory INSTANCE = new DisabledFactory();

		public Simon getSimon(String name) {
			return NullSimon.INSTANCE;
		}

		public Counter getCounter(String name) {
			return NullSimon.INSTANCE;
		}

		public Stopwatch getStopwatch(String name) {
			return NullSimon.INSTANCE;
		}

		public Stopwatch getSimpleStopwatch(String name) {
			return NullSimon.INSTANCE;
		}

		public String generateName(String suffix, boolean includeMethodName) {
			return null;
		}

		public Simon getRootSimon() {
			return NullSimon.INSTANCE;
		}

		public Collection<String> simonNames() {
			return Collections.emptySet();
		}
	}
}
